const isEmpty = value => value === undefined || value === null || value === '' || (typeof value === 'string' && value.trim() === '');
const join = rules => (value, data) => rules.map(rule => rule(value, data)).filter(error => !!error)[0];

export function required(value) {
  if (isEmpty(value)) {
    return 'Required';
  }
  return null;
}

export function alphabet(value) {
  if (!/^[a-zA-Z\s]+$/.test(value)) {
    return 'Alphabet';
  }
  return null;
}

export function createValidator(rules) {
  return (data = {}) => {
    const errors = {};
    Object.keys(rules).forEach((key) => {
      if (Array.isArray(rules[key])) {
        const rule = join([].concat(rules[key]));
        const error = rule(data[key], data);
        if (error) {
          errors[key] = error;
        }
      } else {
        const subErrors = [];
        const itemError = {};
        Object.keys(rules[key]).forEach((subKey) => {
          if (data[key] && data[key].length > 0) {
            const rule = join([].concat(rules[key][subKey]));
            data[key].forEach((item, index) => {
              itemError[subKey] = rule(item[subKey], data);
              subErrors[index] = itemError;
            });
            if (!errors[key]) {
              errors[key] = {};
            }
          }
        });

        if (subErrors.length !== 0) {
          errors[key] = subErrors;
        }
      }
    });
    return errors;
  };
}
